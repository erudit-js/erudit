import gen from './gen';

const myAttr: ProblemCustomAttribute = {
    label: 'ЕГЭ Физика',
    hint: ' фывафы вафывал фджывалфывла ыфвлал жфвыла лыв',
};

export default defineDocument({
    uniques: {
        bruteForceRules: Important,
        wonderfulDay: Problem,
        numberFinder: Problem,
        hats: Problem,
        tree: Term,
    },
})(({ uniques }) => (
    <>
        <H1>Зачем это нужно?</H1>

        <BlockMath>{math`
            \lim\limits_{n \to \infty} \frac{1}{n} = \frac{n}{\infty} \text{ (ну почти)}
        `}</BlockMath>

        <P>
            Очень многие <Ref to="https://google.com">комбинаторные задачи</Ref>{' '}
            можно решить просто вручную, составив все возможные комбинации.
        </P>

        <Reference to={$CONTENT.combinatorics}>Лол кек чебурек</Reference>

        <List type="ul">
            <Li>Зачем вообще проходить эту тему?</Li>
            <Li>Перебрать варианты любой ведь сможет!</Li>
            <Li>
                Мы ведь и зашли в этот{' '}
                <Ref to={$CONTENT.combinatorics}>учебник</Ref>, чтобы изучать
                приёмы быстрого решения!
            </Li>
        </List>

        <P>
            Эти и подобные вопросы и возмущения понятны. Но прежде чем научиться
            летать, нужно сначала научиться ползать. Прежде чем узнать о хитрых
            приёмах, надо сначала изучить и отработать базу -- перебор вариантов
            вручную.
        </P>

        <P>
            Не волнуйтесь, у прямого перебора вариантов тоже есть свои хитрые
            приёмы и весьма интересные задачи. Скучно не будет.
        </P>

        <H1>Перебираем с умом</H1>

        <P>
            Казалось бы, что может быть проще!? Просто берёшь и выписываешь все
            возможные комбинации! Как бы да, но при бездумном и бессистемном
            выписывании очень легко можно пропустить какую-то комбинацию. Или
            посчитать одну и ту же дважды. Чтобы такого не происходило, нужно
            придерживаться двух простых правил:
        </P>

        <Important
            title="Правила перебора"
            $={uniques.bruteForceRules}
            snippet={{ quick: true }}
        >
            <List type="ol">
                <Li>
                    Каждому элементу дать уникальное и короткое обозначение.
                </Li>
                <Li>
                    Придумать удобный алгоритм перебора и строго ему следовать.
                </Li>
            </List>
        </Important>

        <P>
            Уникальные обозначения элементам нужно давать, чтобы не держать в
            голове сложные сущности. Превратить их в что-то простое -- буквы или
            символы. Именно так сущности вроде "яблок", "апельсинов" и "бананов"
            во время решения задачи превращаются в обезличенные буквы "я", "а" и
            "б".
        </P>

        <P>
            Алгоритм перебора помогает не запутаться, не пропустить комбинации и
            не посчитать лишние. При правильном выборе алгоритма решение задачи
            на перебор из пытки превращается в повторение чётких действий,
            которое неизбежно приведёт к правильным результатам.
        </P>

        <P>
            На словах правила звучат довольно просто. Теперь научимся применять
            их для решения задач. Начнём с чего-нибудь простого:
        </P>

        <Problem title="Генерящаяся проблема" level="hard" script={gen()} />

        <Problem
            title="Насыщенный день"
            level="example"
            attributes={['applied', myAttr]}
            $={uniques.wonderfulDay}
        >
            <ProblemDescription>
                Пётр должен убраться в комнате, сделать домашнее задание и
                поработать над личным проектом. Сделать нужно всё, но Пётр ещё
                не решил, в какой последовательности. Сколькими способами он
                может выбрать эту последовательность?
            </ProblemDescription>

            <ProblemSolution>
                <P>
                    Обозначим уборку в комнате буквой "У", домашнее задание
                    буквой "Д", а работу над личным проектом буквой "П". Введя
                    эти обозначения, мы выполнили первый пункт{' '}
                    <Dep to={uniques.bruteForceRules}>правил перебора</Dep>.
                </P>

                <P>
                    Перебирать будем так: сначала разберем варианты, когда буква
                    "У" стоит первой, потом второй, затем последней. Введя такой
                    порядок мы выполнили второй пункт правил перебора.
                    Приступаем:
                </P>

                <BlockMath>{`
                    \\bm{У}\\text{ДП} \\quad \\bm{У}\\text{ПД}
                    \\\
                    \\text{Д}\\bm{У}\\text{П} \\quad \\text{П}\\bm{У}\\text{Д}
                    \\\
                    \\text{ДП}\\bm{У} \\quad \\text{ПД}\\bm{У}
                `}</BlockMath>

                <P>
                    Всего <M>6</M> способов распланировать <M>3</M> дела на
                    день.
                </P>

                <Hr />

                <P>
                    Предложенный выше алгоритм через фиксацию буквы может
                    подойти не всем. Кому-то удобнее записывать варианты в
                    алфавитном порядке. Делайте так, как удобно вам. Главное --{' '}
                    <B>строго придерживайтесь</B> выбранного алгоритма!
                </P>
                <ProblemSection title="Привет мир">sdfsdf</ProblemSection>
            </ProblemSolution>

            <ProblemAnswer>Hello World!</ProblemAnswer>

            <ProblemCheck label="lol" answer={3} />
        </Problem>

        <P>
            В некоторых задачах предстоит работать с числами и цифрами. Они и
            так записываются коротко и хорошо друг от друга отличаются. Поэтому
            им, обычно, не нужно придумывать уникальные обозначения и первое
            <Dep to={uniques.bruteForceRules}>правило перебора</Dep> можно
            считать автоматически выполненным.
        </P>

        <Problem
            title="В поисках чисел"
            $={uniques.numberFinder}
            level="example"
        >
            <ProblemDescription>
                Сколько существует четырехзначных чисел, сумма цифр которых
                меньше <M>4</M>?
            </ProblemDescription>

            <ProblemSolution>
                <P>
                    Мы работаем с числами, поэтому уникальные обозначения
                    вводить не надо. Но все еще нужно выполнить второе правило
                    перебора -- придумать удобный алгоритм.
                </P>

                <P>
                    Чтобы не запутаться, не потерять и лишний раз не засчитать
                    числа, будем указывать их в <B>порядке возрастания</B>: от
                    маленьких к большим. То есть каждое следующее число должно
                    быть больше предыдущего. И помним, что сумма цифр в числе
                    должна быть меньше <M>4</M>, то есть равна <M>1</M>,{' '}
                    <M>2</M> или <M>3</M>.
                </P>

                <BlockMath>{`
                    1000, \\
                    1001, \\
                    1002, \\
                    1010, \\
                    1011, \\
                    1020, \\
                    1100, \\
                    1101, \\
                    1110, \\
                    1200, \\\

                    2000, \\
                    2001, \\
                    2010, \\
                    2100, \\\

                    3000
                `}</BlockMath>
            </ProblemSolution>
        </Problem>

        <P>
            Будем честны, предыдущие примеры вполне можно было решить без всяких
            правил, просто наобум перебирая дела и числа. Да, это было бы дольше
            и не так удобно, но все же возможно. Рассмотрим теперь пример
            задачи, которую без правил перебора решить, скорее всего, не выйдет.
        </P>

        <Problem
            title="Задача Эйлера о шляпах"
            level="example"
            $={uniques.hats}
        >
            <ProblemDescription>
                Ресторан посетили <M>4</M> человека. Свои шляпы они отдали
                швейцару. На выходе невнимательный швейцар раздал шляпы
                случайным образом. Сколько существует вариантов, когда каждый
                гость получил чужую шляпу?
            </ProblemDescription>

            <ProblemSolution>
                <P>
                    Дадим каждому человеку свой номер от <M>1</M> до <M>4</M>.
                    Каждой шляпе тоже дадим номер. Причем номер шляпы совпадает
                    с номером ее владельца. Шляпа <M>3</M> принадлежит гостю{' '}
                    <M>3</M> и так далее.
                </P>

                <P>
                    Дальше придумаем, как удобно обозначать варианты выдачи
                    шляп. Будем записывать их в виде набора из четырех цифр,
                    причем позиция цифры означает человека, а сама цифра номер
                    шляпы. Например, набор <M>1234</M> означает, что каждый
                    человек получил свою шляпу. А набор <M>1243</M> означает,
                    что третий человек получил шляпу четвертого, а четвертый
                    шляпу третьего:
                </P>

                <BlockMath>{`
                    \\overset{1\\text{ч}}{1} \\ \\overset{2\\text{ч}}{2} \\ \\overset{3\\text{ч}}{4} \\ \\overset{4\\text{ч}}{3}
                `}</BlockMath>

                <P>
                    Мы свели задачу к тому, что нужно просто найти все наборы из
                    четырех цифр, в которых{' '}
                    <B>позиция каждой цифры не равна самой цифре</B>.
                </P>

                <P>
                    Введя подобные обозначения, мы выполнили первое
                    <Dep to={uniques.bruteForceRules}>правило</Dep> прямого
                    перебора. Но как не запутаться и перечислить все такие
                    наборы цифр? Для этого надо придумать грамотный алгоритм
                    перебора (<M>2</M>-е правило перебора).
                </P>

                <P>
                    Построим таблицу, в верхней строчке которой укажем номера
                    гостей. Потом добавляем строки с четырехзначными числами в{' '}
                    <B>порядке возрастания</B>. Следим за тем, чтобы номер шляпы
                    не совпал с номером человека. Такие варианты вычеркиваем:
                </P>

                <BlockMath>{`
                    \\def\\arraystretch{1.5}
                    \\begin{array}{cccc}
                        1\\text{ч} & 2\\text{ч} & 3\\text{ч} & 4\\text{ч} \\\\ \\hline
                        \\red{2} & \\red{1} & \\red{3} & \\fcolorbox{red}{transparent}{\\red{4}} \\\\
                        2 & 1 & 4 & 3 \\\\
                        \\red{2} & \\red{3} & \\red{1} & \\fcolorbox{red}{transparent}{\\red{4}} \\\\
                        2 & 3 & 4 & 1 \\\\
                        2 & 4 & 1 & 3 \\\\
                        \\red{2} & \\red{4} & \\fcolorbox{red}{transparent}{\\red{3}} & \\red{1}
                    \\end{array}
                `}</BlockMath>

                <P>
                    Красным цветом помечены неподходящие варианты, то есть когда
                    гость получил свою шляпу. В красную рамочку взяты номера
                    шляп, которые попали в руки своих владельцев.
                </P>

                <P>
                    Продолжая в том же духе, после вычеркивания всех лишних
                    наборов, останется таблица во всеми нужными нам вариантами
                    раздачи шляп:
                </P>

                <BlockMath>{`
                    \\def\\arraystretch{1.5}
                    \\begin{array}{cccc}
                        1\\text{ч} & 2\\text{ч} & 3\\text{ч} & 4\\text{ч} \\\\ \\hline
                        2 & 1 & 4 & 3 \\\\
                        2 & 3 & 4 & 1 \\\\
                        2 & 4 & 1 & 3 \\\\ \\hline
                        3 & 1 & 4 & 2 \\\\
                        3 & 4 & 1 & 2 \\\\
                        3 & 4 & 2 & 1 \\\\ \\hline
                        4 & 1 & 2 & 3 \\\\
                        4 & 3 & 1 & 2 \\\\
                        4 & 3 & 2 & 1
                    \\end{array}
                `}</BlockMath>

                <P>
                    Получаем всего <M>9</M> вариантов, когда каждый гость
                    получил чужую шляпу.
                </P>
            </ProblemSolution>
        </Problem>

        <P>
            Заметили, что самое сложное в таких задачах -- как раз таки
            выполнить два правила: ввести обозначения и придумать алгоритм? Но
            когда оба пункта правил выполнены, то думать уже не надо. Остается
            только аккуратно и внимательно перебирать варианты. Из всего этого
            следует довольно простой вывод:
        </P>

        <Important title="Терпение и труд...">
            Если соблюдать{' '}
            <Dep to={uniques.bruteForceRules}>правила перебора</Dep>, то
            множество комбинаторных задач можно решить полным (прямым)
            перебором. Скорее всего это будет долго, но правильный ответ все
            равно будет получен.
        </Important>

        <H1>Дерево вариантов</H1>

        <P>
            В большинстве задач дать элементам уникальные обозначения (выполнить
            первое правило перебора) не составляет труда. Проблемы возникают на
            втором шаге -- придумывании алгоритма перебора. Порой ну никак не
            получается нащупать удобный механизм.
        </P>

        <P>
            Тут главное не отчаиваться, ведь существует универсальный, удобный,
            наглядный и безотказный механизм, который носит гордое название
            "дерево вариантов".
        </P>

        <Term
            title="Дерево вариантов"
            $={uniques.tree}
            snippet={{ quick: true }}
        >
            Универсальный алгоритм построения и перебора комбинаций.
            <Br />В этом алгоритме все варианты обозначаются в виде расходящихся
            "веток дерева".
        </Term>

        <P>
            Как там говорят? Любой человек должен создать семью, построить дом и
            посадить дерево? Не знаю, что там насчет первых пунктов, но дерево
            мы с вами сейчас посадим.
        </P>

        <H2>Построение дерева</H2>

        <P>
            В <Ref to={uniques.wonderfulDay}>первом примере</Ref> этой статьи мы
            искали все способы составить расписание на день. Каждое дело
            обозначили своей буквой: уборка -- "У", домашнее задание -- "Д",
            личный проект -- "П". Таким образом, задача свелась к поиску всех
            способов записать друг за другом три буквы: "У", "Д" и "П". Найдем
            все эти способоы с помощью дерева вариантов.
        </P>

        <P>
            Рисуем точку. Это семечко нашего дерева, его стартовый или нулевой{' '}
            <B>узел</B>. На первое место в комбинациях мы можем поставить любую
            из трех букв. Поэтому из стартового узла "вырастают" три{' '}
            <B>ветки</B> первого уровня. Три ветки -- три буквы:
        </P>
    </>
));
